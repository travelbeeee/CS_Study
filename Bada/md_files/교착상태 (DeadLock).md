### 교착상태 (DeadLock)

#### 교착상태 (DeadLock) 이란?

운영체제에서 교착상태는, 시스템 자원에 대한 요구가 뒤엉킨 상태를 말한다. 

둘 이상의 프로세스가 서로 이벤트가 끝나길 기다리는 상황이 발생해 무한 대기에 빠지는 현상을 말한다. 

#### 동기화 Synchronization

동기화 문제를 잘 해결하지 못하면 교착상태에 빠질 수 있다. 

동기화란 작업들 사이에 실행 시기를 맞추는 것을 말하는데요,

동기화 문제를 잘 해결하지 못하면 동일한 자원을 여러 스레드가 동시에 수정하게 되어, 각 스레드 결과에 영향을 준다.

따라서 이를 관리해주는 것이 필요하다. 

#### 임계 구역 Critical Section

임계구역이란 동기화가 필요한 공유 자원 영역을 말합니다.  

여러 프로세스(스레드)가 동시에 접근할 수 있기 때문에 공유 자원 접근 순서에 따라서 실행 결과가 달라지는 프로그램 영역을 말한다.

즉, 동시에 실행하면 안되는 영역이다. 

#### 교착상태(DeadLock) 발생 조건

4 가지 조건이 모두 성립해야 발생한다. 

1. 상호 배제 (Mutual Exclusion) 

   프로세스들이 자원에 대해 **배타적인 통제권**을 요구한다.

   상호 배제 기능이 있을 때 

2. 점유 대기 (Hold and wait)

   프로세스가 **할당된 자원을 가진 상태**에서 다른 자원을 기다린다. 

   독점적으로 자원을 사용할 때

3. 비선점 (No preemption)

   프로세스가 어떤 자원의 사용을 끝내고 반납할 때 까지, **강제적으로 뺏을 수 없다**.

   한 번 이벤트를 시작하면 끝날 때 까지 중단할 수 없을 때

4. 순환 대기 (Circular wait)

   각 프로세스는 **순환적으로** 다음 프로세스가 요구하는 자원을 가지고 있다. 

   프로세스들이 꼬리에 꼬리를 물면서 hold and wait에 빠질 때

네 가지 조건을 모두 달성했다고 해서 항상 교착상태가 생기는 것은 아니다. 각 프로세스를 어떤 순서로 실행하느냐에 따라 발생할 수도 있고 발생하지 않을 수도 있다. 

→ 교착상태 발생 시에, 위 네 가지 조건중 일부를 제외하면 문제를 해결할 수 있다. 

####  교착상태(Deadlock) 해결책 

** 면접에서 자주 물어본다 

1. 타조 전략 

   문제를 무시하고 재부팅

2. OS의 주기적인 Deadlock Detection 

   utilization 이 많이 떨어진 프로세스가 존재할 경우 교착상태로 의심한다. 

   교착상태가 발생했다면 해당 프로세스를 죽인다. 

3. Deadlock 회피 

   자원 할당시에 Deadlock 발생 가능성이 있으면 자원을 할당하지 않는다. 

   ** Banker(은행원) Algorithm

   '은행이 최소한 한 명에게 대출해줄 수 있는 금액을 항상 보유하고 있어야 한다'는 개념에서 나왔다.

   은행원 알고리즘이 수행되기 위해서는 세 가지 개념이 필요하다.

   1. MAX

      > 각 프로세스들의 자원 요청량의 최댓값
      >
      > (각 고객들이 최대로 요구할 돈의 액수)

   2. Allocated

      > 각 프로세스들이 현재 보유하고 있는 자원의 양
      >
      > (각 고객들이 현재 빌려간 돈의 액수)

   3. Available

      > 시스템의 자원 보유량
      >
      > (은행이 보유하고, 빌려줄 수 있는 돈의 액수)

   은행원 알고리즘이 어떻게 작동하는지 예시를 들어보자.

   <img src="..\images\은행원_1.png" alt="은행원_1" style="zoom:67%;" />

   

   위와 같은 상황에서 

   t=0일 때 P1이 5개, P2가 2개, P3이 2개를 가져간 상황이라고 했을 때 이 상태는 안전상태라고 할 수 있다.

   ![image-20211011162122581](..\images\은행원_2.png)

   하지만 시스템은 안전 상태에서 불완전 상태로 변할 수 있다. 

   t=1에서 P3이 1개의 자원을 추가로 요청했다고 했을 때,

   ![image-20211011162845378](..\images\은행원_3.png)

   결론은, 운영체제는 t=1에서 P3이 자원 한 개를 더 요청했을 때 이 것이 불완전 상태에 빠질 가능성이 있기 때문에 빌려주지 않을 것이다. 그리고 이것이 DeadLock 회피이다. 

   이렇게 시스템이 안전 상태를 유지할 수 있게 하는 것이 은행원 알고리즘이다. 

4. Deadlock 예방 

   위의 4가지 조건을 없애버린다.



Deadlock 예방을 위해,  임계구역에 두 개 이상의 프로세스가 동시에 접근하지 못하도록 Locking이 필요하다. Locking의 종류에는 Mutex, Semaphores, Monitor 등이 있다. 

이들은 병행 처리를 위한 프로세스 동기화 기법이다.

#### Mutex

초기값을 1과 0으로 가진다. 

임계영역에 들어갈 때 lock을 걸어 다른 프로세스가 접근하지 못하도록 하고, 임계영역에서 나올 때 unlock을 한다. 

#### Semaphores

세마포어는 정수 값을 가지는 변수로 볼 수 있다. 이 정수 값은 동시에 해당 자원에 접근할 수 있는 프로세스(스레드)의 수를 의미한다. 

**semWait 연산**: 세마포어 값을 감소시킨다. 만일 값이 음수가 되면 semWait를 호출한 프로세스는 블록된다. 음수가 아니면, 프로세스는 계속 수행될 수 있습니다.

**semSignal 연산**: 세마포어 값을 증가시킨다. 만약 값이 양수가 아니면(0이거나 음수면), semWait 연산에 의해 블록된 프로세스들을 깨운다.

**세마포어의 종류**

1. 범용 세마포어 (카운팅 세마포어)

   위에서 설명한 세미포어가 범용 세마포어이다. 

2. 이진 세마포어

   0,1의 값만 가질 수 있는 세마포어이다. 뮤텍스가 이진 세마포어와 같다. 

큐에 블록된 프로세스들이 여러개 있을 때 어떤 순서로 깨울 것인지에 따라 두 가지로 나뉜다. 

1. 강성 세마포어

   큐에서 선입선출로 꺼낸다.

2. 약성 세마포어

   큐에서 제거되는 순서를 명시하지 않았다. 

#### Mutex vs Semaphores

- 세마포어는 공유 자원에 **세마포어의 변수만큼의 프로세스가 접근**할 수 있다. 반면에 뮤텍스는 **오직 1개만의 프로세스만 접근**할 수 있다.
- 현재 수행중인 프로세스가 아닌 **다른 프로세스가 세마포어를 해제할 수 있다.** 하지만 뮤텍스는 **락(lock)을 획득한 프로세스가 반드시 그 락을 해제**해야 한다.

#### Monitor 

하나의 프로세스 내에서 다른 스레드 간에 동기화 할 때 사용된다. 

** 뮤텍스는 프로세스간 동기화에 이용된다.

뮤텍스나 세마포어에 비해 프레임워크나 라이브러리에서 기본적으로 많이 제공되고 있기 때문에 가볍고 빠르다. 

Java에서는 모니터를 모든 객체에 기본적으로 제공하고 있다. 

세마포어는 실제로 카운터 변수값을 프로그래머가 매번 값을 지정해줘야 하는 등 번거로움이 있는데, 모니터는 이러한 일들이 캡슐화 되어 있어서 개발자는 카운터 값을 뭘로 지정할지 고민할 필요 없이 synchronized, wait(), notify() 등의 키워드를 이용해 좀 더 편하게 동기화할 수 있다.



** 기아상태 : 프로세스가 끊임없이 필요한 컴퓨터 자원을 가져오지 못하는 상황으로, 이러한 자원 없이는 처리를 끝낼 수 없는 병행 컴퓨팅에서 마주치는 문제이다.

** 뮤텍스 손코딩도 자주 물어본다. 